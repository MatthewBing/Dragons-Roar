package cuaccessibility.dragons_roar.voice;

import android.text.TextUtils;

import java.util.AbstractMap.SimpleEntry;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Phonetic algorithm class to deal with parsing dice rolls from a transcription. It's not very
 * robust but should prove useful.
 *
 * Note that this class should never be instantiated.
 *
 * Created by Evan on 3/15/17.
 */


public class PhoneticAlg {

    private final String LOG = "PHONALG: ";


    /**
     * Don't instantiate this class!
     */
    private void PhoneticAlg(){
        throw new AssertionError();
    }

    /**
     * Creates a soundex-esque code from a string.
     *
     * This method assigns 0 to vowels, semivowels and h, 1 to labials, 2 to velars and alveolars,
     * 3 to t or d, 4 to l, 5 to nasals, and 6 to r. Sequential duplicates are removed.
     *
     * @param in the string of text that we would like to turn into a code.
     * @return the code which has been generated
     */
    private String generateCode(String in){
        StringBuilder codeString = new StringBuilder();
        in = in.toLowerCase().trim();

        for (int i=0; i < in.length(); i++){
            switch(in.charAt(i)){
                case 'a':
                case 'e':
                case 'i':
                case 'o':
                case 'u':
                case 'y':
                case 'w':
                case 'h':
                    codeString.append('0');
                    break;
                case 'b':
                case 'f':
                case 'p':
                case 'v':
                    codeString.append('1');
                    break;
                case 'c':
                case 'g':
                case 'j':
                case 'k':
                case 'q':
                case 's':
                case 'x':
                case 'z':
                    codeString.append('2');
                    break;
                case 'd':
                case 't':
                    codeString.append('3');
                    break;
                case 'l':
                    codeString.append('4');
                    break;
                case 'm':
                case 'n':
                    codeString.append('5');
                    break;
                case 'r':
                    codeString.append('6');
                    break;
            }

        }
        for (int i = 1; i < codeString.length(); i++){
            if (codeString.charAt(i-1) == codeString.charAt(i)){
                codeString.replace(i, i+1, "");
            }
        }
        return codeString.toString();
    }

    /**
     * Finds the 'd' seperator in an obfuscated XdX input.
     *
     * @param code A string containing a code in the style generated by generateCode()
     * @see this.generateCode()
     * @return The provided string, sans the 'd' seperator.
     * @throws Exception Thrown if no 'd' seperator is found.
     */
    private String findD(String code) throws Exception {
        for (int i = code.length() - 1; i > 0; i--) {
            if (code.substring(i-1, i+1).equals("30")) {
                //then d is found, return
                return code.substring(0, i-1);
            }
        }

        throw new Exception();
    }

    /**
     * Given a code string as input, attempts to find the last number represented in it.
     *
     * @param code A string containing a code in the style generated by generateCode()
     * @see this.generateCode()
     * @return a number represented in the code
     * @throws Exception
     */
    private SimpleEntry<Integer, String> findNum(String code, boolean allowComplex) throws Exception {
        //Note: see if this can be done more efficiently and compactly
        Pattern numberRegexPattern = Pattern.compile("(050)|(05)|(30)|(3060)|(106)|(1010)|(101)|" +
                "(202)|(20105)|(0203)|(030)|(505)|(305)|(040105)|(30410)|(306305)|(106305)|" +
                "(101305)| (202305)|(20105305)|(020305)|(0305)|(5050305)|505305|(30630)|(30530)|" +
                "(10630)|(10130)|(20230)|(2010530)|(02030)|(030)|(505030)|(50530)|(053603)|(05360)");
        Matcher numberRegexMatcher;
        String bestMatch = "";
        int numValue = 0;
        int priorLength = code.length();

        for (int i = code.length() - 1; i > code.length()-9 && i >= 0; i--){
            numberRegexMatcher = numberRegexPattern.matcher(code.substring(i, code.length()));
            if (numberRegexMatcher.matches()) {
                bestMatch = code.substring(i, code.length());
                priorLength = i;
            }
        }

        numValue += TextNumber.lookupValue(bestMatch);

        if (numValue < 10 && allowComplex){
            try{
                numberRegexPattern = Pattern.compile("(30630)|(30530)|(10630)|(10130)|(20230)|" +
                        "(2010530)|(02030)|(030)|(505030)|(50530)|(053603)|(05360)|(053603053)|" +
                        "(05360305)");
                bestMatch = "";
                code = code.substring(0, priorLength);
                for (int i = code.length() - 1; i > code.length()-8 && i >= 0 ; i--){
                    numberRegexMatcher = numberRegexPattern.matcher(code.substring(i, code.length()));
                    if (numberRegexMatcher.matches()){
                        bestMatch = code.substring(i, code.length());
                        priorLength = i;
                    }
                }
                numValue += TextNumber.lookupValue(bestMatch);
            }catch (Exception e){
                return new SimpleEntry(numValue, code.substring(0, priorLength));
            }
        }

        if (numValue < 100 && allowComplex){
            try{
                numberRegexPattern = Pattern.compile("(053603)|(05360)|(053603053)|(05360305)");
                bestMatch = "";
                code = code.substring(0, priorLength);
                for (int i = code.length() - 1; i > code.length()-10 && i >= 0 ; i--){
                    numberRegexMatcher = numberRegexPattern.matcher(code.substring(i, code.length()));
                    if (numberRegexMatcher.matches()){
                        bestMatch = code.substring(i, code.length());
                        priorLength = i;
                    }
                }
                numValue += TextNumber.lookupValue(bestMatch);
            }catch (Exception e){
                return new SimpleEntry(numValue, code.substring(0, priorLength));
            }
        }
        return new SimpleEntry(numValue, code.substring(0, priorLength));
    }

    /**
     * Attempts to find both X values in obfuscated XdX from a transcribed spoken command.
     *
     * @param transcription A transcribed spoken command from the user
     * @return both values being sought
     * @throws Exception Something didn't work at some stage.
     */
    //Still has some flaws - will work out later
    public SimpleEntry parseBothValues(String transcription) throws Exception {
        int dice, size;
        String transcriptionCode = generateCode(transcription);
        try{
            SimpleEntry<Integer, String> entry = findNum(transcriptionCode, false);
            size = entry.getKey();
            transcriptionCode = entry.getValue(); //transcriptionCode.substring(0, transcriptionCode.length() - TextNumber.lookupCode(size).length()); //redo this
            dice = parseDiceValue(transcriptionCode);
            return new SimpleEntry<Integer, Integer>(dice, size);
        }catch(Exception e){
            e.printStackTrace();
            throw new Exception();
        }
    }

    /**
     * Attempts to find the first X value in obfuscated XdX from a transcribed spoken command.
     *
     * @param transcription A transcribed spoken command from the user
     * @return the value being sought
     * @throws Exception Something didn't work at some stage.
     */
    public int parseDiceValue(String transcription) throws Exception {
        int dice;
        String transcriptionCode;

        if (!TextUtils.isDigitsOnly(transcription)){
            transcriptionCode = generateCode(transcription);
        }else{
            transcriptionCode = transcription;
        }

        transcriptionCode = findD(transcriptionCode);
        dice = findNum(transcriptionCode, true).getKey();

        return dice;
    }

}
